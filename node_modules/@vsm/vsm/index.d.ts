declare namespace Vsm {
    export class Map {
        constructor(options: MapOptions);

        requestRenderFrame(runnable?: () => void): Task | null;

        requestRepaint(): void;

        cancelRepaint(): void;

        resize(eventData?: EventData): void;

        getContainer(): HTMLElement;

        getCanvasContainer(): HTMLElement;

        getCanvas(): HTMLCanvasElement;

        setControlDock(
            name: string,
            dockContainer: HTMLElement | null
        ): HTMLElement | null;

        getControlDock(name: MapControlDockName | string): HTMLElement | null;

        addControl(
            control: MapControl,
            dockName?: MapControlDockName | string
        ): Map;

        removeControl(control: MapControl): Map;

        replaceControl(newControl: MapControl, oldControl: MapControl): Map;

        on<E extends Event>(name: EventName, listener: EventListener<E>): Map;

        once<E extends Event>(name: EventName, listener: EventListener<E>): Map;

        off<E extends Event>(name: EventName, listener?: EventListener<E>): Map;

        emit(event: Event): Map;

        listens(name: EventName): boolean;

        enable(
            ...additionalFuncNames: Array<MapAdditionalFuncName | string>
        ): Map;

        disable(
            ...additionalFuncNames: Array<MapAdditionalFuncName | string>
        ): Map;

        isEnabled(additionalFuncName: MapAdditionalFuncName | string): boolean;

        setConfig(
            config: string | InformalObject | null,
            options?: AppConfigOptions,
            globalVariables?: {
                fontScale?: number;
                iconScale?: number;
                enlargeScaleFactor?: EnlargeScaleFactor;
                customStyleProperties?: InformalObject;
            }
        ): void;

        getConfig(): InformalObject | null;
        getFetchedConfig(): InformalObject | null;

        getAvailableStyles(): { [name: string]: Array<string> };

        getCurrentStyle(): InformalObject | null;

        getStyleProperties(
            options?: StyleQueryOptions & {
                layerId: number;
                stackId: number;
                styleId: number;
                paintGroup: keyof StylePaintProp;
                paintProp: string;
            }
        ): null | any;
        getStyleProperties(
            options?: StyleQueryOptions & {
                layerId: number;
                stackId: number;
                styleId: number;
                paintGroup: keyof StylePaintProp;
            }
        ):
            | null
            | GeometryStyleOptions
            | IconStyleOptions
            | LabelStyleOptions
            | PoiStyleOptions;
        getStyleProperties(
            options?: StyleQueryOptions & {
                layerId: number;
                stackId: number;
                styleId: number;
            }
        ): null | StyleItem;
        getStyleProperties(
            options?: StyleQueryOptions & { layerId: number; stackId: number }
        ): null | StyleItem[];
        getStyleProperties(
            options?: StyleQueryOptions & { layerId: number }
        ): null | StackStyles;
        getStyleProperties(
            options?: StyleQueryOptions
        ): null | Record<number, StackStyles>;

        setStyleProperties(options: StyleChangeOptions): void;

        loadStyle(name: string, type: string): Promise<void>;

        getId(): string;

        isMoving(): boolean;

        isInteracting(): boolean;

        destroy(): void;

        getTransform(): MapTransform;

        getCamera(): MapCamera;

        project(lngLat: LngLatCompatible): ScreenPoint;

        unproject(point: ScreenPointCompatible): LngLat;

        setInteractive(interactive: MapInteractive): void;

        getInteractive(): MapInteractive;

        addStyle(layerId: number, stackStyles: StackStyles): Promise<void>;

        removeStyle(layerId: number): Promise<void>;

        addLayer(layerConfig: LayerConfig, order?: number): Promise<void>;

        removeLayer(layerId: number): Promise<void>;

        hasLayer(layerId: number): boolean;

        updateGeoJsonSourceData(
            layerId: number,
            data: GeoJsonSourceSpec['data']
        ): Promise<void>;

        addImageResources(
            packageCode: string,
            images: Array<IdentifiedImage>,
            options?: ImagePackageOptions
        ): Promise<void>;

        queryRenderedFeatures(
            geometry: ScreenPointCompatible | ScreenBoundsCompatible,
            options?: QueryRenderedFeaturesOptions
        ): QueryResultRenderedFeatureCollection;

        getActiveLayers(): Array<{ id: number; type?: string }>;

        getPoiScale(): { fontScale: number; iconScale: number };

        setPoiScale(scale: {
            fontScale?: number;
            iconScale?: number;
        }): Promise<void>;

        getEnlargeScaleFactor(): EnlargeScaleFactor;

        setEnlargeScaleFactor(scaleFactor: EnlargeScaleFactor): Promise<void>;

        getCustomStyleProperties(): InformalObject;

        setCustomStyleProperties(properties: InformalObject): Promise<void>;

        reload(layerIds?: Array<number>): void;

        static ControlDockNames: typeof MapControlDockName;
        static EventNames: typeof MapEventName;
        static ErrorNames: typeof MapErrorName;
        static AdditionalFuncNames: typeof MapAdditionalFuncName;
        static TileServiceNames: typeof TileServiceName;

        static isSupported: (canvas?: HTMLCanvasElement) => boolean;
    }

    type MapLimitOptions = {
        minZoom?: number;
        maxZoom?: number;
        minPitch?: number;
        maxPitch?: number;
        maxBounds?: LngLatBoundsCompatible;
    };

    type AppConfigOptions = {
        autoStyleLoad?: boolean;
        preloadStyle?: boolean;
        defaultStyle?: { name: string; type: string };
    };

    type PoiScaleOptions = {
        fontScale?: number;
        iconScale?: number;
    };

    type MapOptions = CameraOptions &
        MapLimitOptions &
        AppConfigOptions &
        PoiScaleOptions & {
            container: HTMLElement | string;
            alt?: HTMLElement;
            config: string | InformalObject | null;
            id?: string;
            enlargeScaleFactor?: EnlargeScaleFactor;
            interactive?: MapInteractive;
            preserveDrawingBuffer?: boolean;
            fadeDuration?: number;
            bounds?: LngLatBoundsCompatible; // bounds가 있는 경우 center, zoom 무시
            padding?: PaddingOptions | number; // bounds와 함께 동작
            maxPreparationTimePerFrame?: number;
            emitFirstPaint?: boolean;
            customStyleProperties?: InformalObject;
            optimize?: MapOptimize;
        };

    type IdentifiedImage = {
        id: string;
        image:
            | HTMLImageElement
            | ImageBitmap
            | ImageData
            | SvgData
            | PngData
            | PngSpriteData;
    };

    type SvgData = {
        type: 'svg';
        data: string;
    };

    type PngData = {
        type: 'png';
        data: ArrayBuffer;
    };

    type PngSpriteData = {
        type: 'sprite';
        data: ArrayBuffer;
        index: {
            [id: string]: {
                x: number;
                y: number;
                width: number;
                height: number;
            };
        };
    };

    type ImagePackageOptions = {
        pixelRatio?: number;
    };

    enum MapControlDockName {
        Default = 'Default',
        TopLeft = 'TopLeft',
        TopRight = 'TopRight',
        BottomLeft = 'BottomLeft',
        BottomRight = 'BottomRight'
    }

    export enum MapEventName {
        Click = 'Click',
        DoubleClick = 'DoubleClick',
        MouseDown = 'MouseDown',
        MouseUp = 'MouseUp',
        MouseMove = 'MouseMove',
        MouseOver = 'MouseOver',
        MouseOut = 'MouseOut',
        ContextMenu = 'ContextMenu',
        Wheel = 'Wheel',

        TouchStart = 'TouchStart',
        TouchMove = 'TouchMove',
        TouchEnd = 'TouchEnd',
        TouchCancel = 'TouchCancel',
        LongTap = 'LongTap',

        MoveStart = 'MoveStart',
        Move = 'Move',
        MoveEnd = 'MoveEnd',
        DragStart = 'DragStart',
        Drag = 'Drag',
        DragEnd = 'DragEnd',
        ZoomStart = 'ZoomStart',
        Zoom = 'Zoom',
        ZoomEnd = 'ZoomEnd',
        RotateStart = 'RotateStart',
        Rotate = 'Rotate',
        RotateEnd = 'RotateEnd',
        PitchStart = 'PitchStart',
        Pitch = 'Pitch',
        PitchEnd = 'PitchEnd',

        Resize = 'Resize',
        Render = 'Render',
        Idle = 'Idle',
        FirstPaint = 'FirstPaint',
        RenderComplete = 'RenderComplete',
        Data = 'Data',
        ConfigLoad = 'ConfigLoad',
        StyleLoad = 'StyleLoad',
        Destroy = 'Destroy',

        Error = 'Error',
        ContextLost = 'ContextLost',

        LimitOptionsChanged = 'LimitOptionsChanged'
    }

    enum MapErrorName {
        Config = 'Config',
        Source = 'Source',
        Initialize = 'Initialize'
    }

    enum MapAdditionalFuncName {
        ShowTileDebugInfo = 'ShowTileDebugInfo',
        ShowVectorTileDebugInfo = 'ShowVectorTileDebugInfo',
        ShowLegacyVectorTileDebugInfo = 'ShowLegacyVectorTileDebugInfo',
        ShowLegacyRasterTileDebugInfo = 'ShowLegacyRasterTileDebugInfo',
        ShowCollisionDetection = 'ShowCollisionDetection',
        ShowPoiVertex = 'ShowPoiVertex',
        ShowNetwork = 'ShowNetwork'
    }

    enum TileServiceName {
        GoogleMap = 'GoogleMap',
        VsmVector = 'VsmVector',
        VsmRaster = 'VsmRaster',
        VsmLegacyVector = 'VsmLegacyVector',
        VsmLegacyRaster = 'VsmLegacyRaster'
    }

    type InformalObject = { [key: string]: any };
    type EventName = string;
    type EventData = InformalObject;
    type EventListener<E extends Event = Event> = (event: E) => any;

    class Event {
        constructor(name: EventName, data?: EventData);

        get name(): EventName;

        get data(): EventData;
    }

    class MapEvent extends Event {
        get target(): Map;

        preventDefault(): void;

        get defaultPrevented(): boolean;
    }

    class MapError {
        get name(): string;

        get message(): any;
    }

    class MapErrorEvent extends Event {
        get error(): MapError;
    }

    interface Task {
        run(): void;

        cancel(): void;

        isReady(): boolean;

        isCancelled(): boolean;

        isRunning(): boolean;

        isDone(): boolean;
    }

    type Point = { x: number; y: number };
    type PointCompatible = Point | [number, number];

    type ProjectedCoordinate = Point;

    type ScreenPoint = Point;
    type ScreenPointCompatible = PointCompatible;

    type ScreenBounds = {
        left: number;
        top: number;
        right: number;
        bottom: number;
    };

    type ScreenBoundsCompatible =
        | ScreenBounds
        | [ScreenPointCompatible, ScreenPointCompatible] // [tl, br]
        | [number, number, number, number]; // [left, top, right, bottom]

    type BBox = { minX: number; maxX: number; minY: number; maxY: number };

    type LngLatCompatible =
        | LngLat
        | { lng: number; lat: number }
        | [number, number]; // [x, y]

    type LngLatBoundsObjectCompatible = {
        west: number;
        south: number;
        east: number;
        north: number;
    };
    type LngLatBoundsCompatible =
        | LngLatBounds
        | [LngLatCompatible, LngLatCompatible] // [sw, ne]
        | [number, number, number, number] // [west, south, east, north]
        | LngLatBoundsObjectCompatible;

    class LngLat {
        constructor(lng: number, lat: number);

        static valueOf(lngLat: LngLatCompatible): LngLat;

        get lng(): number;

        get lat(): number;

        get circumference(): number;

        wrap(): LngLat;

        toString(): string;

        toArray(): [number, number]; // lng,lat
    }

    class LngLatBounds {
        constructor(sw: LngLat, ne: LngLat);

        static valueOf(lngLatBounds: LngLatBoundsCompatible): LngLatBounds;

        get southWest(): LngLat;

        get northEast(): LngLat;

        getCenter(): LngLat;

        extend(
            coordOrBounds: LngLatCompatible | LngLatBoundsCompatible
        ): LngLatBounds;

        contains(coord: LngLatCompatible): boolean;

        toString(): string;

        toArray(): [[number, number], [number, number]]; // sw lng, lat, ne lng, lat
    }

    class TileId {
        constructor(z: number, x: number, y: number);

        get z(): number;

        get x(): number;

        get y(): number;

        toString(): string;

        newChildren(): Array<TileId>;
    }

    type TileIdObject = { z: number; x: number; y: number };

    type EnlargeScaleFactor = 1 | 2 | 4;

    type MapInteractive =
        | boolean
        | {
              pan?: boolean;
              zoom?: boolean;
              rotate?: boolean;
              pitch?: boolean;
              drag?: boolean;
              wheel?: boolean;
              doubleClick?: boolean;
              touch?: boolean;
              keyInput?: boolean;
              longTap?: boolean;
          };

    type MapOptimize = {
        noQuery?: boolean; // default : false
        tessellationPreset?: 'Medium' | 'SlowAndTolerant'; // default : 'Medium'
    };

    interface MapDefine {
        getBounds(): BBox;

        getMinLevel(): number;

        getMaxLevel(): number;

        getTileSize(): number;

        getResolution(level: number): number;

        toScale(level: number): number;

        toLevel(scale: number): number;

        getTileEnvelope(level: number, x: number, y: number): BBox;
    }

    interface MapProjector {
        project(lngLat: LngLat): ProjectedCoordinate;

        unproject(coord: ProjectedCoordinate): LngLat;

        normalize(coord: ProjectedCoordinate): ProjectedCoordinate;

        toOfficial(coord: ProjectedCoordinate): ProjectedCoordinate;
    }

    interface MapTransform {
        resize(width: number, height: number): void;

        getWidth(): number;
        getHeight(): number;

        getMapDefine(): MapDefine;

        getMapProjector(): MapProjector;

        getFov(): number;
        setFov(fov: number): void;

        getZoom(): number;
        setZoom(zoom: number): void;

        getMinZoom(): number;
        setMinZoom(zoom: number): void;

        getMaxZoom(): number;
        setMaxZoom(zoom: number): void;

        getScale(): number;

        getBearing(): number;
        setBearing(bearing: number): void;

        getPitch(): number;
        setPitch(pitch: number): void;

        getMinPitch(): number;
        setMinPitch(pitch: number): void;

        getMaxPitch(): number;
        setMaxPitch(pitch: number): void;

        getCenter(): LngLat;

        setCenter(lngLat: LngLatCompatible): void;

        getMaxBounds(): LngLatBounds | null;
        setMaxBounds(bounds: LngLatBoundsCompatible): void;

        setLocationAtPoint(
            lngLat: LngLatCompatible,
            point: ScreenPointCompatible
        ): void;

        getWorldSize(): number;

        getCenterPoint(): ScreenPoint;

        getNearestPointFromEye(): ScreenPoint;

        getCameraToCenterDistance(): number;

        screenPointToPrjCoord(
            point: ScreenPointCompatible
        ): ProjectedCoordinate;

        prjCoordToLngLat(coord: ProjectedCoordinate): LngLat;

        screenPointToLngLat(point: ScreenPointCompatible): LngLat;

        lngLatToPrjCoord(lngLat: LngLatCompatible): ProjectedCoordinate;

        prjCoordToScreenPoint(coord: ProjectedCoordinate): ScreenPoint;

        lngLatToScreenPoint(lngLat: LngLatCompatible): ScreenPoint;

        project(lngLat: LngLatCompatible): ScreenPoint;

        unproject(point: ScreenPointCompatible): LngLat;

        isVisible(bbox: BBox): boolean;

        isVisibleTile(tileId: TileId): boolean;

        isVisibleDataTile(
            tileId: TileId,
            tileServiceName: TileServiceName
        ): boolean;

        getVisibleTiles(): Array<TileId>;

        getTileBBox(tileId: TileId): BBox;

        getDataTileBBox(tileId: TileId, tileServiceName: TileServiceName): BBox;

        toDataTiles(
            tileId: TileId,
            tileServiceName: TileServiceName
        ): Array<TileId>;
    }

    type CameraOptions = {
        center?: LngLatCompatible;
        zoom?: number;
        bearing?: number;
        pitch?: number;
    };

    type AnimationOptions = {
        offset?: Point;
        duration?: number;
        easing?: (timePercent: number) => number;
        animate?: boolean;
        noMoveStart?: boolean;
    };

    type FlyAnimationOptions = {
        speed?: number;
        curve?: number;
        minZoom?: number;
        maxDuration?: number;
    };

    type PaddingOptions = {
        top: number;
        right: number;
        bottom: number;
        left: number;
    };

    type SetBoundsOptions = {
        padding?: PaddingOptions | number;
    } & CameraOptions &
        AnimationOptions &
        FlyAnimationOptions;

    interface MapCamera {
        easeTo(
            cameraOptions: CameraOptions,
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        panTo(
            lngLat: LngLatCompatible,
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        panBy(
            offset: Point,
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        zoomTo(
            zoom: number,
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        zoomIn(
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        zoomOut(
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        rotateTo(
            bearing: number,
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        resetNorth(
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        resetPitch(
            animationOptions?: AnimationOptions,
            eventData?: EventData
        ): void;

        jumpTo(cameraOptions: CameraOptions, eventData?: EventData): void;

        flyTo(
            cameraOptions: CameraOptions,
            animationOptions?: AnimationOptions & FlyAnimationOptions,
            eventData?: EventData
        ): void;

        stop(): void;

        getZoom(): number;
        setZoom(zoom: number, eventData?: EventData): void;

        getMinZoom(): number;
        setMinZoom(zoom: number, eventData?: EventData): void;

        getMaxZoom(): number;
        setMaxZoom(zoom: number, eventData?: EventData): void;

        getCenter(): LngLat;
        setCenter(center: LngLatCompatible, eventData?: EventData): void;

        getBearing(): number;
        setBearing(bearing: number, eventData?: EventData): void;

        getPitch(): number;
        setPitch(pitch: number, eventData?: EventData): void;

        getMinPitch(): number;
        setMinPitch(pitch: number, eventData?: EventData): void;

        getMaxPitch(): number;
        setMaxPitch(pitch: number, eventData?: EventData): void;

        setBounds(
            bounds: LngLatBoundsCompatible,
            setBoundsOptions?: SetBoundsOptions,
            eventData?: EventData
        ): void;
        getBounds(): LngLatBounds;

        getMaxBounds(): LngLatBounds | null;
        setMaxBounds(
            bounds: LngLatBoundsCompatible | null,
            setBoundsOptions?: SetBoundsOptions,
            eventData?: EventData
        ): void;

        isMoving(): boolean;

        isZooming(): boolean;

        isRotating(): boolean;

        isPitching(): boolean;
    }

    type HtmlStyleProps = {
        className?: string;
        style?: Partial<CSSStyleDeclaration>;
    };

    type HtmlButtonProps = HtmlStyleProps & {
        disabled?: boolean;
        innerText?: string;
        innerHTML?: string;
    };

    type HtmlFlexDirection = 'row' | 'column';
    type SvgProps = HtmlStyleProps & { svgText?: string };
    type ButtonClickHandler = (event: MouseEvent, map: Map) => void;
    type CoordinateFormat = (coordinate: Point) => string;

    type MapControlContainerProps = { interactive?: boolean };
    type LayoutControlProps = HtmlStyleProps & { control: MapControl };
    type GroupControlProps = HtmlStyleProps & { controls: Array<MapControl> };
    type ButtonControlProps = HtmlButtonProps & {
        onClick?: ButtonClickHandler;
    };
    type SvgButtonControlProps = ButtonControlProps & { svgProps?: SvgProps };

    type SvgMapButtonControlProps = ButtonControlProps & {
        svgPropsMap?: { [name: string]: SvgProps };
        selectedName?: string | null;
    };

    type CenterPointerControlProps = HtmlStyleProps & {
        svgProps?: SvgProps;
        size?: string;
    };
    type ZoomInControlProps = SvgButtonControlProps;
    type ZoomOutControlProps = SvgButtonControlProps;
    type CompassControlProps = SvgButtonControlProps;
    type PitchAlignerControlProps = SvgButtonControlProps;

    type NavigationControlProps = HtmlStyleProps & {
        direction?: HtmlFlexDirection;
        buttonSize?: string;
        buttonStyle?: Partial<CSSStyleDeclaration>;
        buttonClassName?: string;
        showZoom?: boolean;
        showRotate?: boolean;
        showPitch?: boolean;
        disabled?: boolean;
    };

    type FullScreenControlProps = HtmlButtonProps & {
        enterSvgProps?: SvgProps;
        exitSvgProps?: SvgProps;
    };

    type HtmlElementControlProps = {
        contents: HTMLElement;
        interactive?: boolean;
    };
    type ScaleBarControlProps = HtmlStyleProps & { maxPixelWidth?: number };

    type MyLocationControlProps = HtmlButtonProps & {
        disableOnMapMove?: boolean;
        positionOptions?: PositionOptions;
        animationOptions?: AnimationOptions;
        offSvgProps?: SvgProps;
        watchPositionSvgProps?: SvgProps;
        watchPositionAndHeadingSvgProps?: SvgProps;
    };

    type TransformViewControlProps = HtmlStyleProps & {
        lngLatFormat?: CoordinateFormat;
        titleProps?: HtmlStyleProps & { text?: string };
        propertyContainerProps?: HtmlStyleProps;
        propertyNameProps?: HtmlStyleProps;
        propertyValueProps?: HtmlStyleProps;
    };

    type MousePointControlProps = HtmlStyleProps & {
        lngLatFormat?: CoordinateFormat;
        epsg3857Format?: CoordinateFormat;
        crsList?: Array<{
            code: string;
            wkt?: string;
            format?: CoordinateFormat;
        }>;
        titleProps?: HtmlStyleProps & { text?: string };
        propertyContainerProps?: HtmlStyleProps;
        propertyNameProps?: HtmlStyleProps;
        propertyValueProps?: HtmlStyleProps;
    };

    type ViewFinderControlProps = HtmlStyleProps & { lineWidth?: number };

    interface MapControl {
        createDom(map: Map): HTMLElement;

        onAdd(map: Map): void;

        onRemove(map: Map): void;
    }

    export namespace MapControls {
        abstract class AbstractMapControl implements MapControl {
            abstract createDom(map: Map): HTMLElement;

            onAdd(map: Map): void;

            onRemove(map: Map): void;
        }

        class MapControlContainer extends AbstractMapControl {
            constructor(props?: MapControlContainerProps);

            createDom(map: Map): HTMLElement;

            getContainer(): HTMLElement;
        }

        class LayoutControl extends MapControlContainer {
            constructor(props: LayoutControlProps);

            static from(
                control: MapControl,
                props: HtmlStyleProps
            ): LayoutControl;

            static fromStyle(
                control: MapControl,
                style: Partial<CSSStyleDeclaration>
            ): LayoutControl;

            static fromClass(
                control: MapControl,
                className: string
            ): LayoutControl;

            getControl(): Readonly<MapControl>;
        }

        class GroupControl extends MapControlContainer {
            constructor(props: GroupControlProps);

            getControls(): ReadonlyArray<MapControl>;
        }

        class ButtonControl extends MapControlContainer {
            constructor(props?: ButtonControlProps);

            getButton(): HTMLButtonElement;

            isDefaultDisabled(): boolean;
        }

        class SvgButtonControl extends ButtonControl {
            constructor(props?: SvgButtonControlProps);

            getSvg(): SVGElement | null;
        }

        class SvgMapButtonControl extends ButtonControl {
            constructor(props?: SvgMapButtonControlProps);

            select(name: string | null): void;

            getSelectedName(): string | null;

            getSvgMap(): Readonly<{ [name: string]: SVGElement | null }>;

            getSelectedSvg(): SVGElement | null;
        }

        class CenterPointerControl extends MapControlContainer {
            constructor(props?: CenterPointerControlProps);
        }

        class ZoomInControl extends AbstractMapControl {
            constructor(props?: ZoomInControlProps);

            createDom(map: Map): HTMLElement;
        }

        class ZoomOutControl extends AbstractMapControl {
            constructor(props?: ZoomOutControlProps);

            createDom(map: Map): HTMLElement;
        }

        class CompassControl extends AbstractMapControl {
            constructor(props?: CompassControlProps);

            createDom(map: Map): HTMLElement;
        }

        class PitchAlignerControl extends AbstractMapControl {
            constructor(props?: PitchAlignerControlProps);

            createDom(map: Map): HTMLElement;
        }

        class NavigationControl extends AbstractMapControl {
            constructor(props?: NavigationControlProps);

            createDom(map: Map): HTMLElement;

            getControls(): ReadonlyArray<MapControl>;
        }

        class FullScreenControl extends AbstractMapControl {
            constructor(props?: FullScreenControlProps);

            createDom(map: Map): HTMLElement;

            isFullScreen(): boolean;
        }

        class HtmlElementControl extends MapControlContainer {
            constructor(props: HtmlElementControlProps);

            getContents(): HTMLElement;
        }

        class ScaleBarControl extends MapControlContainer {
            constructor(props?: ScaleBarControlProps);
        }

        class MyLocationControl extends AbstractMapControl {
            constructor(props: MyLocationControlProps);

            createDom(map: Map): HTMLElement;
        }

        class TransformViewControl extends MapControlContainer {
            constructor(props?: TransformViewControlProps);
        }

        class MousePointControl extends MapControlContainer {
            constructor(props?: MousePointControlProps);
        }

        class ViewFinderControl extends MapControlContainer {
            constructor(props?: ViewFinderControlProps);
        }

        function layoutCtrl(
            control: MapControl,
            props: HtmlStyleProps
        ): LayoutControl;

        function layoutCtrlClass(
            control: MapControl,
            className: string
        ): LayoutControl;

        function layoutCtrlStyle(
            control: MapControl,
            style: Partial<CSSStyleDeclaration>
        ): LayoutControl;

        function createDock(
            props?: HtmlStyleProps,
            parent?: HTMLElement | null,
            nested?: boolean
        ): HTMLElement;

        function isInstanceOfMapControl(object: any): boolean;
    }

    type Anchor =
        | 'center'
        | 'left'
        | 'right'
        | 'top'
        | 'bottom'
        | 'top-left'
        | 'top-right'
        | 'bottom-left'
        | 'bottom-right';

    interface DefaultMarkerOptions {
        map?: Map;
        lngLat?: LngLatCompatible;
        offset?: Point;
        anchor?: Anchor;
        color?: string;
        scale?: number;
        hideOnUpdate?: boolean;
    }

    interface CustomMarkerOptions {
        element: HTMLElement;
        map?: Map;
        lngLat?: LngLatCompatible;
        offset?: Point;
        anchor?: Anchor;
        hideOnUpdate?: boolean;
    }

    type MarkerOptions = DefaultMarkerOptions | CustomMarkerOptions;

    export class Marker {
        constructor(options?: MarkerOptions);
        setMap(map?: Map): void;
        destroy(): void;
        getElement(): HTMLElement;
        getLngLat(): LngLatCompatible | void;
        setLngLat(lngLat: LngLatCompatible): void;
        getColor(): string | undefined;
        setColor(color: string): void;
        getAnchor(): Anchor;
        setAnchor(anchor: Anchor): void;
        getOffset(): Point;
        setOffset(offset: Point): void;
    }

    export interface LayerConfig {
        id: number;
        map: SourceSpec;
        name: string;
        stacks: StackSpec[];
        properties?: Record<string, any>;
        type?: string;
        uri?: string;
        version?: string;
    }

    export interface GeoJsonSourceSpec {
        format: 'geojson';
        data: GeoJsonFeature | GeoJsonFeatureCollection | string; // url
        preventOverlap?: boolean;
        minZoom?: number; // 0 ~
        maxZoom?: number; // ~ 21
    }
    export interface UrlSourceSpec {
        format: 'vsm2' | 'vsm4' | 'vsm8' | 'jpeg' | 'ld1' | 'network' | 'mvt';
        uri: string; // url
        version?: string;
        preventOverlap?: boolean;
        minZoom?: number; // 0 ~
        maxZoom?: number; // ~ 21
    }
    export interface ImageSourceSpec {
        format: 'image';
        uri: string; // url
        bbox: LngLatBoundsCompatible;
    }

    export type SourceSpec =
        | UrlSourceSpec
        | GeoJsonSourceSpec
        | ImageSourceSpec;

    export type GeometryType = 'LINE' | 'POLYGON' | 'POINT';
    export interface StackSpec {
        id: number;
        name: string;
        priority?: number;
        properties?: Record<string, any>;
        viewLevels?: number[];
        geometryType?: GeometryType;
        noPopupCategories?: string[];
        clip?: number;
        code?: string;
    }

    export interface PoiStack extends StackSpec {
        geometryType: 'POINT';
        properties: {
            poi: '1' | '2' | '3'; // 일반주기 / 행정주기 / 특수주기
            sortBy: 'grade';
        };
    }

    export interface CircleStack extends StackSpec {
        geometryType: 'POINT';
        properties: {
            circle: true;
        };
    }

    export interface DotMapStack extends StackSpec {
        geometryType: 'POINT';
        properties: {
            circle: true;
            radiusBy: string; // feature prop name
        };
    }

    export interface HeatMapStack extends StackSpec {
        geometryType: 'POINT';
        properties: {
            heatmap: true;
            weightBy: string; // feature prop name
            weightRange: [number, number];
        };
    }

    export type StackStyles = Record<number, StyleItem[]>;
    export type StylePaintProp = {
        geometry?: GeometryStyleOptions;
        icon?: IconStyleOptions;
        label?: LabelStyleOptions;
        poi?: PoiStyleOptions;
    };
    export type StyleItem = StylePaintProp & {
        id: number;
        condition: string;
        priority?: number;
    };

    type HexColor = string;

    interface PolylineStyleOptions {
        'stroke'?: string;
        'stroke-width'?: string | number;
        'stroke-opacity'?: string | number;
        'stroke-dasharray'?: string;
        'stroke-pattern'?: string;

        'display'?: 'off' | 'on';
    }

    interface PolygonStyleOptions {
        'fill'?: string;
        'fill-opacity'?: string | number;
        'fill-pattern'?: string;

        'stroke'?: string;
        'stroke-width'?: string | number;
        'stroke-opacity'?: string | number;

        'display'?: 'off' | 'on';
    }

    interface CircleStyleOptions {
        'circle-radius'?: number; // px

        'fill'?: string;
        'fill-opacity'?: string | number;

        'stroke'?: string;
        'stroke-width'?: string | number;
        'stroke-opacity'?: string | number;

        'display'?: 'off' | 'on';
    }

    interface HeatmapStyleOptions {
        'circle-radius'?: number; // px
        'fill-opacity'?: string | number;
        'heatmap-colors'?: Record<string | number, string>;

        'display'?: 'off' | 'on';
    }

    export type GeometryStyleOptions =
        | PolylineStyleOptions
        | PolygonStyleOptions
        | CircleStyleOptions
        | HeatmapStyleOptions;

    export interface PlacementStyleOptions {
        'justify'?: 'center' | 'left' | 'right';
        'align-x'?: 'center' | 'left' | 'right';
        'align-y'?: 'mid' | 'top' | 'bottom';

        'offset-x'?: string | number;
        'offset-y'?: string | number;

        'gap-left'?: string | number;
        'gap-right'?: string | number;
        'gap-top'?: string | number;
        'gap-bottom'?: string | number;
    }

    export interface LabelStyleOptions extends PlacementStyleOptions {
        'font-size'?: string | number; // '14'=> based on dp(usually px * 4/3) | '14px'
        'font-weight'?: string | number; // 100, 200, 300, 400(normal), 500, 600 , 700, 800, 900

        'fill'?: HexColor;
        'fill-opacity'?: string | number;

        'stroke'?: HexColor;
        'stroke-opacity'?: string | number;
        'stroke-width'?: string | number;

        'label-optional'?: boolean;
        'label-allow-overlap'?: boolean;

        'placement'?: PlacementStyleOptions[];

        'display'?: 'off' | 'on';
    }

    export interface IconStyleOptions {
        'icon'?: string;
        'icon-size'?: string | number; // image 크기의 n 배

        'align-x'?: 'center' | 'left' | 'right';
        'align-y'?: 'mid' | 'top' | 'bottom';

        'offset-x'?: string | number;
        'offset-y'?: string | number;

        'icon-optional'?: boolean;
        'icon-allow-overlap'?: boolean;

        'display'?: 'off' | 'on';
    }

    export interface PoiStyleOptions {
        'keep-upright'?: boolean;
        'pitch-alignment'?: 'map' | 'viewport';
        'rotation-alignment'?: 'map' | 'viewport';
        'line-alignment'?: 'line' | 'line-center';
        'line-alignment-min-spacing'?: string | number;
        'line-alignment-max-angle'?: string | number;
    }

    type StyleQueryOptions = {
        styleName?: string;
        styleType?: string;
        layerId?: number;
        stackId?: number;
        styleId?: number;
        paintGroup?: keyof StylePaintProp;
        paintProp?:
            | keyof GeometryStyleOptions
            | keyof IconStyleOptions
            | keyof LabelStyleOptions
            | keyof PoiStyleOptions;
    };

    type ValueOf<T> = T[keyof T];
    type GeomStyleChange = {
        paintGroup: 'geometry';
        paintProp: keyof GeometryStyleOptions;
        paintValue: ValueOf<GeometryStyleOptions>;
    };

    type LabelStyleChange = {
        paintGroup: 'label';
        paintProp: keyof LabelStyleOptions;
        paintValue: ValueOf<LabelStyleOptions>;
    };

    type IconStyleChange = {
        paintGroup: 'icon';
        paintProp: keyof IconStyleOptions;
        paintValue: ValueOf<IconStyleOptions>;
    };

    type PoiStyleChange = {
        paintGroup: 'poi';
        paintProp: keyof PoiStyleOptions;
        paintValue: ValueOf<PoiStyleOptions>;
    };

    type MultiStyleChange = {
        paintGroup?: undefined;
        paints: StyleChange[];
    };

    type StyleChange =
        | GeomStyleChange
        | LabelStyleChange
        | IconStyleChange
        | PoiStyleChange;

    interface StyleChangeOptionsBase {
        styleName?: string;
        styleType?: string;
        layerId: number;
        stackId: number;
        styleId: number;
    }

    export type StyleChangeOptions =
        | (StyleChangeOptionsBase & GeomStyleChange)
        | (StyleChangeOptionsBase & LabelStyleChange)
        | (StyleChangeOptionsBase & IconStyleChange)
        | (StyleChangeOptionsBase & PoiStyleChange)
        | (StyleChangeOptionsBase & MultiStyleChange);

    type QueryRenderedFeaturesOptions = QueryOptions<RenderedFeatureInfo>;
    type QuerySourceFeaturesOptions = QueryOptions<SourceFeatureInfo>;

    type QueryOptions<T extends CombinedFeatureInfo> = {
        buffer?: number;
        targets?: Array<{ layerId: number; stackIds?: Array<number> }>;
        lookupFilter?: (lookupInfo: QueryLookupInfo<T>) => boolean;
        filter?: (feature: GeoJsonFeature, combinedFeatureInfo: T) => boolean;
    };

    type QueryResultRenderedFeatureCollection =
        QueryResultFeatureCollection<RenderedFeatureInfo>;

    type QueryResultFeatureCollection<T extends CombinedFeatureInfo> =
        GeoJsonFeatureCollection<
            GeoJsonGeometry,
            QueryResultFeatureProperties<T>
        >;

    type QueryResultFeatureProperties<T extends CombinedFeatureInfo> =
        GeoJsonProperties & {
            combinedInfo: T;
        };

    type QueryLookupInfo<T extends CombinedFeatureInfo> = T & {
        getFeatureProperty: (name: string) => any;
    };

    type CombinedFeatureInfo = {
        layerId: number;
        stackId: number;
        tileId: TileIdObject;
        geometryType: GeometryType;
    };

    type SourceFeatureInfo = CombinedFeatureInfo;

    type RenderedFeatureInfo = CombinedFeatureInfo & {
        styleId: number;
    };

    type GeoJsonFeatureCollection<
        G extends GeoJsonGeometry = GeoJsonGeometry,
        P = GeoJsonProperties
    > = {
        type: 'FeatureCollection';
        features: Array<GeoJsonFeature<G, P>>;
    };

    type GeoJsonFeature<
        G extends GeoJsonGeometry = GeoJsonGeometry,
        P = GeoJsonProperties
    > = {
        type: 'Feature';
        id?: string | number | undefined;
        geometry: G;
        properties: P;
    };

    type GeoJsonGeometry = {
        type:
            | 'Point'
            | 'MultiPoint'
            | 'LineString'
            | 'MultiLineString'
            | 'Polygon'
            | 'MultiPolygon';
        coordinates: any;
    };

    type GeoJsonProperties = { [name: string]: any } | null;

    export namespace Extensions {
        export namespace Common {
            export type ConnectionLimits = {
                maxConnectionsPerHost?: number;
                maxConnections?: number;
                maxConnectionsPerHostForEachWorker?: number;
                maxConnectionsForEachWorker?: number;
            };

            export function getConnectionLimits(): ConnectionLimits;

            export function setConnectionLimits(limits: ConnectionLimits): void;

            export class FirstPaintChecker {
                constructor();

                reset(): void;

                addTile(event: MapEvent): void;

                check(): boolean;

                isComplete(): boolean;
            }
        }

        export namespace SquareMapUtils {
            export type SquareMapOptions = {
                valuePropName?: string; // default 'val'
                size?: number; // meter, default 10 * 1000
                fillBlank?: boolean; // default false
                domain?: 'world' | 'korea'; // default korea
                styles?: Array<{
                    value: number;
                    style: PolygonStyleOptions;
                }>;
            };

            export type SquareMapData = {
                featureCollection: GeoJsonFeatureCollection<{
                    type: 'Polygon';
                    coordinates: [number, number][][];
                }>;
                stacks: StackSpec[];
                styles: StackStyles;
                legends: SquareMapLegend[];
            };

            export type SquareMapLegend = {
                stackId: number;
                min: number;
                max: number;
                style: PolygonStyleOptions;
            };

            export function convert(
                data: GeoJsonFeatureCollection<{
                    type: 'Point';
                    coordinates: [number, number];
                }>,
                options?: SquareMapOptions
            ): SquareMapData;
        }

        export namespace TmapUtils {
            export type isEnoughSpecOptions = {
                and?: number; // min os major version
                ios?: number;
            };

            export function isEnoughSpec(
                options?: isEnoughSpecOptions
            ): boolean;

            export function setBuildingVisibility(
                map: Map,
                flag: boolean
            ): void;

            export function getClickableLookupFilter(
                map: Map
            ): (info: QueryLookupInfo<RenderedFeatureInfo>) => boolean;

            export const POI_SCALE: Record<
                'small' | 'normal' | 'large',
                Required<PoiScaleOptions>
            >;
        }
    }
}

export = Vsm;
export as namespace Vsm;
